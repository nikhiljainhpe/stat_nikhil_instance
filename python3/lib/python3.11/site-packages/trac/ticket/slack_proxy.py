from flask import Flask, request, jsonify
from flask_cors import CORS
import requests
import os
from datetime import datetime
import logging
import csv
from apscheduler.schedulers.background import BackgroundScheduler
from xmlrpc.client import ServerProxy
from dotenv import load_dotenv
load_dotenv()    # pip install python-dotenv


app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Slack webhook URLs
SLACK_WEBHOOK_URL = os.environ.get('SLACK_WEBHOOK_URL')
ACTIVE_TICKETS_WEBHOOK_URL = os.environ.get('ACTIVE_TICKETS_WEBHOOK_URL')


if not SLACK_WEBHOOK_URL or not ACTIVE_TICKETS_WEBHOOK_URL:
    raise RuntimeError(
        "Missing SLACK_WEBHOOK_URL or ACTIVE_TICKETS_WEBHOOK_URL in environment"
    )

USER_SLACK_MAP = {
    "admin": "U08QMHZF74P",
    # add more mappings here...
}

def mention_for(username):
    slack_id = USER_SLACK_MAP.get(username.lower())
    return slack_id if slack_id else username


def fetch_and_list_active_tickets():
    """
    Fetch the “Active Tickets” report as CSV from Trac,
    parse out ticket ID, summary, and status (in a case‐insensitive way),
    and post the formatted list to Slack.
    """
    try:
        resp = requests.get(
            'http://localhost:8123/report/1?format=csv',
            timeout=10
        )
        resp.raise_for_status()
    except Exception as e:
        logger.error(f"Error fetching CSV from Trac: {e}")
        return

    reader = csv.DictReader(resp.text.splitlines())
    fields = reader.fieldnames or []
    logger.info(f"CSV fields detected: {fields}")
    lc_fields = {name.lower(): name for name in fields}

    id_col      = lc_fields.get('\ufeffticket') or lc_fields.get('ticket #') or lc_fields.get('id')
    summary_col = lc_fields.get('summary')
    status_col  = lc_fields.get('status')

    lines = []
    for row in reader:
        tid = row.get(id_col, '<no id>')
        sm  = row.get(summary_col, '<no summary>')
        st  = row.get(status_col, '<no status>')
        lines.append(f"{tid} • {sm} ({st})")

    text_report = (
        "Active tickets:\n" + "\n".join(lines)
        if lines else
        "No active tickets right now."
    )

    payload = {
        "bot_name": "Active Tickets Bot",
        "ticket_list": text_report,
        "report_url": "http://localhost:8123/system/report/1"
    }

    try:
        slack_resp = requests.post(
            ACTIVE_TICKETS_WEBHOOK_URL,
            json=payload,
            timeout=10
        )
        if slack_resp.status_code != 200:
            logger.error(f"Slack API returned {slack_resp.status_code}: {slack_resp.text}")
    except Exception as e:
        logger.error(f"Error sending message to Slack: {e}")


# -------------------------------------------------------------------
# Scheduler setup (module‐level so routes can see it)
# -------------------------------------------------------------------
scheduler = BackgroundScheduler()
scheduler.add_job(
    func=fetch_and_list_active_tickets,
    trigger="interval",
    minutes=15,      # default polling interval
    id="active-tickets"
)
scheduler.start()


@app.route('/set-interval', methods=['POST'])
def set_interval():
    """
    POST JSON { "interval": <minutes:int> }
    Reschedules the existing APScheduler job to the new interval.
    """
    data = request.get_json(silent=True) or {}
    new_interval = data.get('interval')

    try:
        new_interval = int(new_interval)
        if new_interval <= 0:
            raise ValueError()
    except Exception:
        return jsonify(error="`interval` must be a positive integer"), 400

    try:
        scheduler.reschedule_job(
            job_id="active-tickets",
            trigger="interval",
            hours=new_interval,
            next_run_time = datetime.now()
        )
    except Exception as e:
        logger.error(f"Failed to reschedule job: {e}")
        return jsonify(error=str(e)), 500

    msg = f"✅ Polling interval set to {new_interval} hours."
    logger.info(msg)
    return jsonify(message=msg), 200


@app.route('/slack-proxy', methods=['POST'])
def slack_proxy():
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400

        text = data.get('text', '')
        raw_name = data.get('name', 'Unknown')
        name = mention_for(raw_name)
        ticket_url = data.get('ticket_url', 'http://localhost:8123/report')
        old_status = data.get('old_status', '?')
        new_status = data.get('new_status', '!')

        if not text:
            return jsonify({'error': 'No text provided'}), 400

        slack_payload = {
            "text": text,
            "name": name,
            "ticket_url": ticket_url,
            "old_status": old_status,
            "new_status": new_status
        }

        response = requests.post(
            SLACK_WEBHOOK_URL,
            json=slack_payload,
            timeout=10
        )

        if response.status_code == 200:
            return jsonify({'message': 'Message sent to Slack successfully'}), 200
        else:
            return jsonify({
                'error': 'Failed to send message to Slack',
                'details': response.text
            }), 500

    except requests.exceptions.Timeout:
        return jsonify({'error': 'Timeout when sending to Slack'}), 500
    except requests.exceptions.RequestException:
        return jsonify({'error': 'Network error when sending to Slack'}), 500
    except Exception:
        return jsonify({'error': 'Internal server error'}), 500


@app.route('/health', methods=['GET'])
def health_check():
    """Simple health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat()
    }), 200


@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Endpoint not found'}), 404


@app.errorhandler(405)
def method_not_allowed(error):
    return jsonify({'error': 'Method not allowed'}), 405


if __name__ == '__main__':
    debug_mode = os.environ.get('FLASK_ENV') == 'development'
    port = int(os.environ.get('PORT', 5000))

    logger.info(f"Starting Flask app on port {port} (debug={debug_mode})")
    try:
        app.run(host='0.0.0.0', port=port, debug=debug_mode)
    finally:
        scheduler.shutdown()
