from flask import Flask, request, jsonify
from flask_cors import CORS
import requests
import os
from datetime import datetime
import logging
import csv
from apscheduler.schedulers.background import BackgroundScheduler
from xmlrpc.client         import ServerProxy
import requests, os

app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Slack webhook URL - set this as an environment variable for security
SLACK_WEBHOOK_URL = os.environ.get('SLACK_WEBHOOK_URL', 'https://hooks.slack.com/triggers/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')

# at the top, alongside SLACK_WEBHOOK_URL for your other bot
ACTIVE_TICKETS_WEBHOOK_URL = os.environ.get('ACTIVE_TICKETS_WEBHOOK_URL', 'https://hooks.slack.com/triggers/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')

@app.route('/slack-proxy', methods=['POST'])
def slack_proxy():
    try:
        # Get data from the frontend
        data = request.get_json()
        
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        text = data.get('text', '')
        name = data.get('name', 'Unknown')
        ticket_url = data.get('ticket_url', 'http://localhost:8123/report')
        old_status = data.get('old_status', '?')
        new_status = data.get('new_status', '!')
        
        if not text:
            return jsonify({'error': 'No text provided'}), 400
        
        logger.info(f"Received data: {data}")
        
        # Since we want both 'text' and 'name' as separate variables in Workflow Builder
        slack_payload = {
            "text": text,
            "name": name,
            "ticket_url": ticket_url,
            "old_status": old_status,
            "new_status": new_status
        }
        
        logger.info(f"Sending payload to Slack: {slack_payload}")
        logger.info(f"Received data: {data}")
        
        # Send to Slack
        response = requests.post(
            SLACK_WEBHOOK_URL,
            json=slack_payload,
            timeout=10
        )
        
        logger.info(f"Slack response: Status {response.status_code}, Body: {response.text}")
        
        # Check if Slack request was successful
        if response.status_code == 200:
            logger.info(f"Successfully sent message to Slack for user: {name}, {old_status}, {new_status}")
            return jsonify({'message': 'Message sent to Slack successfully'}), 200
        else:
            logger.error(f"Slack API error: {response.status_code} - {response.text}")
            return jsonify({
                'error': 'Failed to send message to Slack', 
                'status': 'error',
                'details': response.text
            }), 500
            
    except requests.exceptions.Timeout:
        logger.error("Timeout when sending to Slack")
        return jsonify({'error': 'Timeout when sending to Slack'}), 500
    except requests.exceptions.RequestException as e:
        logger.error(f"Request error: {str(e)}")
        return jsonify({'error': 'Network error when sending to Slack'}), 500
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/health', methods=['GET'])
def health_check():
    """Simple health check endpoint"""
    return jsonify({'status': 'healthy', 'timestamp': datetime.now().isoformat()}), 200

@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Endpoint not found'}), 404

@app.errorhandler(405)
def method_not_allowed(error):
    return jsonify({'error': 'Method not allowed'}), 405

def fetch_and_list_active_tickets():
    """
    Fetch the “Active Tickets” report as CSV from Trac,
    parse out ticket ID, summary, and status (in a case‐insensitive way),
    and post the formatted list to Slack.
    """
    try:
        resp = requests.get(
            'http://localhost:8123/report/1?format=csv',
            timeout=10
        )
        resp.raise_for_status()
    except Exception as e:
        logger.error(f"Error fetching CSV from Trac: {e}")
        return

    reader = csv.DictReader(resp.text.splitlines())
    fields = reader.fieldnames or []
    logger.info(f"CSV fields detected: {fields}")
    # map lowercase → real column name
    lc_fields = {name.lower(): name for name in reader.fieldnames}

    # pick the right columns (falling back on common alternatives)
    #fields[0] = fields[0].lstrip('\ufeff')
    id_col      = lc_fields.get('\ufeffticket') or lc_fields.get('ticket #') or lc_fields.get('id')
    summary_col = lc_fields.get('summary')
    status_col  = lc_fields.get('status')

    lines = []
    for row in reader:
        tid = row.get(id_col, '<no id>')
        sm  = row.get(summary_col, '<no summary>')
        st  = row.get(status_col, '<no status>')
        lines.append(f"{tid} • {sm} ({st})")

    if lines:
        text_report = "Active tickets:\n" + "\n".join(lines)
    else:
        text_report = "No active tickets right now."

    payload2 = {
        "bot_name" : "Active Tickets Bot",
        "ticket_list": text_report,
        "report_url": "http://localhost:8123/system/report/1"
        }
    

    try:
        slack_resp = requests.post(
            ACTIVE_TICKETS_WEBHOOK_URL,
            json=payload2,
            timeout=10
        )
        if slack_resp.status_code != 200:
            logger.error(f"Slack API returned {slack_resp.status_code}: {slack_resp.text}")
    except Exception as e:
        logger.error(f"Error sending message to Slack: {e}")


if __name__ == '__main__':
    # 1) set up the 15‑minute scheduler
    scheduler = BackgroundScheduler()
    scheduler.add_job(
        fetch_and_list_active_tickets,
        trigger='interval',
        minutes=1,
        id='active-tickets'
    )
    scheduler.start()

    # 2) read runtime env
    debug_mode = os.environ.get('FLASK_ENV') == 'development'
    port       = int(os.environ.get('PORT', 5000))

    logger.info(f"Starting Flask app on port {port}")
    logger.info(f"Debug mode: {debug_mode}")
    logger.info(f"Slack webhook URL: {SLACK_WEBHOOK_URL}")

    # 3) run Flask, and ensure scheduler shuts down cleanly
    try:
        app.run(host='0.0.0.0', port=port, debug=debug_mode)
    finally:
        scheduler.shutdown()